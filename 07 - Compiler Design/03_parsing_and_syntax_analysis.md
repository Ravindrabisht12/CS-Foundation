# 03. Parsing (Syntax Analysis)

Parsing is the **second phase** of a compiler. It is also known as **syntax analysis**.

- **Input:** A stream of tokens from the lexical analyzer.
- **Output:** A parse tree (or an abstract syntax tree).

## 1. Role of the Parser
The parser's main job is to check if the stream of tokens can be generated by the **context-free grammar (CFG)** of the source language. It determines the syntactic structure of the program.

- It verifies that the tokens are in a valid order.
- It reports any syntax errors.
- It creates a tree-like representation of the code that reflects the grammar, which is then used by later phases.

## 2. Context-Free Grammars (CFG)
As seen in TOC, a CFG is used to define the syntax of a language.
Example: A simple grammar for arithmetic expressions.
`E → E + T | T`
`T → T * F | F`
`F → (E) | id`

This grammar has issues of **left recursion** and **ambiguity**, which parsers must handle.

## 3. Parsing Techniques
There are two main categories of parsing:

### a) Top-Down Parsing
- **Strategy:** Begins with the start symbol of the grammar and tries to derive the input string of tokens. It builds the parse tree from the **root down to the leaves**.
- **Example:** Recursive Descent Parsing.
- **LL(k) Parsers:** A class of top-down parsers that scan the input from **L**eft to right and produce a **L**eftmost derivation, using `k` tokens of lookahead.
  - **LL(1) Parser:** The most common type. It uses one token of lookahead to decide which production rule to apply.
    - Requires a grammar that is not left-recursive and is unambiguous.
    - Can be implemented using a predictive parsing table.

### b) Bottom-Up Parsing
- **Strategy:** Begins with the input string of tokens and tries to "reduce" it back to the start symbol. It builds the parse tree from the **leaves up to the root**.
- **Example:** Shift-Reduce Parsing.
- **LR(k) Parsers:** A class of bottom-up parsers that scan the input from **L**eft to right and produce a **R**ightmost derivation in reverse, using `k` tokens of lookahead.
  - LR parsers are more powerful than LL parsers and can handle a larger class of grammars.
  - They are the preferred method for most modern compilers.

#### Types of LR Parsers
1.  **SLR (Simple LR):** The simplest to implement, but the least powerful. It uses the `FOLLOW` set of a non-terminal to make reduce decisions.
2.  **CLR (Canonical LR):** The most powerful LR parser. It uses a large number of states to store lookahead information, making the parsing table very large.
3.  **LALR (Look-Ahead LR):** A compromise between SLR and CLR. It merges similar CLR states to reduce the table size. It is less powerful than CLR but more powerful than SLR and is the most commonly used type in practice (e.g., in tools like **YACC** and **Bison**).

## 4. Ambiguity and Associativity/Precedence
An **ambiguous grammar** can produce more than one parse tree for the same sentence.
Example: `E → E + E | id`. The string `id + id + id` has two parse trees.

This is a problem because the structure of the parse tree dictates the meaning (e.g., order of operations).

Ambiguity can be resolved by:
1.  **Rewriting the Grammar:** Introduce new non-terminals to enforce precedence and associativity.
    - **Precedence:** `+` has lower precedence than `*`.
    - **Associativity:** `+` is left-associative (`a+b+c` means `(a+b)+c`).
2.  **Parser Directives:** Tools like YACC allow you to explicitly declare the precedence and associativity of operators, which resolves conflicts in the parsing table without changing the grammar.

---
Prev ← `02_lexical_analysis.md` | Next → `04_syntax_directed_translation.md` | Index: `README.md`
