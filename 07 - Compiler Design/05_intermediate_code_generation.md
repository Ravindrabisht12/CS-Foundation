# 05. Intermediate Code Generation

After syntax and semantic analysis, many compilers generate an explicit, machine-independent **intermediate representation (IR)** or **intermediate code**.

- **Input:** A parse tree or abstract syntax tree.
- **Output:** Intermediate code.

## 1. Why Use an Intermediate Representation?
- **Portability:** It separates the front end (source language dependent) from the back end (target machine dependent). To retarget the compiler to a new machine, you only need to write a new back end.
- **Optimization:** Most optimizations are performed on the IR, making them machine-independent.
- **Simplicity:** The IR is typically simpler and more uniform than either the source or target language, making it easier to work with.

## 2. Types of Intermediate Representations
### a) High-Level IR
- Closer to the source language.
- Example: An **Abstract Syntax Tree (AST)** itself can serve as a high-level IR.

### b) Low-Level IR
- Closer to the target machine's instruction set.
- Example: **Three-Address Code (TAC)**.

## 3. Three-Address Code (TAC)
This is the most common form of intermediate code. A TAC instruction has at most **three** addresses (operands) and one operator.
The general form is: `result = operand1 op operand2`

**Example:**
Source statement: `x = a + b * c;`
Three-Address Code:
`t1 = b * c`
`t2 = a + t1`
`x = t2`

- `t1` and `t2` are temporary variables generated by the compiler.
- Each instruction performs a single, fundamental operation.

### Common TAC Instructions
- **Assignment:** `x = y op z` or `x = op y` or `x = y`
- **Unconditional Jump:** `goto L`
- **Conditional Jump:** `if x relop y goto L`
- **Procedure Calls:** `param x`, `call p, n`, `y = call p, n`
- **Indexed Assignment:** `x = y[i]`, `x[i] = y`
- **Address and Pointer:** `x = &y`, `x = *y`, `*x = y`

## 4. Implementation of Three-Address Code
TAC can be represented in memory in several ways:

### a) Quadruples
- A "quad" has four fields: `op`, `arg1`, `arg2`, and `result`.
- This is the most common representation. It's easy to work with and reorder.

**Example:** `t1 = b * c`
| op | arg1 | arg2 | result |
|---|---|---|---|
| `*` | `b` | `c` | `t1` |

### b) Triples
- A "triple" has three fields: `op`, `arg1`, and `arg2`.
- The result of an operation is referred to by its position (the line number of the instruction).
- This saves space but makes code motion for optimization difficult, as moving an instruction changes its "name".

**Example:**
1: `( *, b, c )`
2: `( +, a, (1) )`  // (1) refers to the result of instruction 1
3: `( =, x, (2) )`

### c) Indirect Triples
- A compromise that uses a list of pointers to the triples.
- To move code, you just reorder the pointers in the list, not the triples themselves.

## 5. Generating TAC
Three-address code is generated using a **Syntax-Directed Translation Scheme**. As the parser processes the grammar, semantic actions are executed to generate the TAC instructions.

**Example:** For the production `E → E₁ + E₂`, the semantic action would be:
`E.code = E₁.code || E₂.code || new_instruction('+', E₁.addr, E₂.addr, new_temp())`
where `||` denotes concatenation of code sequences.

---
Prev ← `04_syntax_directed_translation.md` | Next → `06_runtime_environments.md` | Index: `README.md`
